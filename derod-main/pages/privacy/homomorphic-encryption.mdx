---
title: "Homomorphic Encryption: DERO's Account Privacy Innovation | DERO Blockchain"
description: "Technical deep dive into DERO's homomorphic encryption system using ElGamal, enabling encrypted account balances and operations on encrypted data for blockchain applications."
keywords: ["homomorphic encryption", "ElGamal encryption", "DERO encryption", "encrypted balances", "additive homomorphism", "partially homomorphic encryption", "blockchain encryption", "encrypted operations", "DERO accounts", "cryptographic commitments"]
date: "2025-10-18"
lastUpdated: "2025-11-01"
authors: ["DHEBP"]
image: "/assets/homomorphic-encryption.jpeg"
slug: "homomorphic-encryption"
canonicalUrl: "https://derod.org/privacy/homomorphic-encryption"
tags: ["privacy", "encryption", "homomorphic", "technical", "cryptography"]
---

import { Callout } from 'nextra/components'
import { Tabs } from 'nextra/components'

# Homomorphic Encryption: Math on Locked Boxes

<Callout type="success" emoji="üîí">
**The Innovation:** Do math on encrypted balances without ever decrypting them. Your balance stays private. Forever. Even the blockchain never sees it.
</Callout>

## What Problem Does It Solve?

**The Challenge:**
```
Blockchain needs to:
  ‚úì Verify transactions (amounts valid)
  ‚úì Update balances (addition/subtraction)
  ‚úì Ensure no double-spending
  
But WITHOUT revealing:
  ‚úó Account balances
  ‚úó Transaction amounts
  ‚úó Any private information
```

**The Solution: Homomorphic Encryption**
- ‚úÖ Math happens on encrypted data
- ‚úÖ No decryption ever required
- ‚úÖ Privacy never broken
- ‚úÖ Blockchain can verify without seeing amounts

---

## The Simple Analogy

<Tabs items={['Regular Encryption', 'Homomorphic Encryption']}>
  <Tabs.Tab>
    **Locked Safe (Regular Encryption)**

```
You have $500 in a locked safe
Someone sends you $100

Normal way:
  1. Open safe (decrypt) ‚Üí See $500
  2. Add $100 ‚Üí Now $600
  3. Lock safe again (encrypt)
  
Problem: When safe is open, anyone can see $500
    Privacy: ‚ùå Broken
```
  </Tabs.Tab>

  <Tabs.Tab>
    **Magic Safe (Homomorphic Encryption)**

```
You have $500 in a magic safe
Someone sends you $100

Magic way:
  1. Drop $100 through slot in safe
  2. Money inside automatically becomes $600
  3. Safe NEVER opened
  
Result: Nobody ever sees $500, not even for a second
    Privacy: ‚úÖ Perfect
```
  </Tabs.Tab>
</Tabs>

**For DERO:**
- Balance is **always** encrypted (safe always locked)
- Math happens on the encrypted number
- Safe never opens
- Blockchain never sees actual balance

---

## How It Works

### The Encryption Flow

```mermaid
flowchart TD
    A["Amount: 100 DERO"] --> B["Pick Random 'r'"]
    B --> C["Calculate:<br/>L = 100√óG + r√óP<br/>R = r√óG"]
    C --> D["Encrypted: E(100) = (L, R)"]
    D --> E["Looks like random<br/>elliptic curve points"]
    E --> F["Network sees: E(100)"]
    F --> G["Network learns: NOTHING"]
```

**The Setup:**
```
Private key: x (your secret)
Public key:  P = x √ó G (everyone can see this)
Generator:   G (elliptic curve point - public constant)
```

### Encrypting an Amount

**From Source Code** (`cryptography/crypto/algebra_elgamal.go`):

```go
// Encrypt 100 DERO:
// 1. Pick random number 'r'
// 2. Calculate Left:  L = 100√óG + r√óP
// 3. Calculate Right: R = r√óG
// 4. Ciphertext: E(100) = (L, R)

// Result: Looks like random elliptic curve points
// Network cannot determine the amount
```

| Step | What Happens | What Network Sees |
|------|-------------|-------------------|
| **1. Pick random 'r'** | Generate random number | Nothing |
| **2. Calculate L** | `L = 100√óG + r√óP` | Random elliptic curve point |
| **3. Calculate R** | `R = r√óG` | Random elliptic curve point |
| **4. Result** | `E(100) = (L, R)` | Random points (no amount visible) |

### The Magic: Homomorphic Operations

**Addition & Subtraction on Encrypted Data:**

```mermaid
graph LR
    A["E(500)<br/>Encrypted"] --> C["Homomorphic<br/>Operations"]
    B["E(100)<br/>Encrypted"] --> C
    C --> D["E(500) + E(100)<br/>= E(600)"]
    C --> E["E(500) - E(100)<br/>= E(400)"]
    D --> F["Result: STILL ENCRYPTED"]
    E --> F
```

**The Math:**
```
E(a) = (L‚ÇÅ, R‚ÇÅ)
E(b) = (L‚ÇÇ, R‚ÇÇ)

Addition:
  E(a) + E(b) = (L‚ÇÅ + L‚ÇÇ, R‚ÇÅ + R‚ÇÇ) = E(a + b)
  
Subtraction:
  E(a) - E(b) = (L‚ÇÅ - L‚ÇÇ, R‚ÇÅ - R‚ÇÇ) = E(a - b)

The encrypted result is STILL encrypted!
No decryption needed at any step!
```

<Callout type="info" emoji="üîê">
  **Mathematical Guarantee:** Based on elliptic curve discrete logarithm problem - same security assumption as Bitcoin. 256-bit security level.
</Callout>

---

## Transaction Flow: Alice ‚Üí Bob

**Alice sends 100 DERO to Bob:**

```mermaid
sequenceDiagram
    participant A as Alice
    participant BC as Blockchain
    participant B as Bob
    
    A->>A: Encrypt: E(100)
    A->>BC: Send E(100) commitment
    BC->>BC: Verify: E(500) - E(100) = E(400)
    BC->>BC: Verify: E(200) + E(100) = E(300)
    BC->>BC: Check: E(500) + E(200) = E(400) + E(300)
    BC->>B: Update: E(300)
    B->>B: Decrypt: 300 DERO received
    
    Note over BC: Network never learned:<br/>Amounts, balances, or any values
```

### What Happens at Each Step

<Tabs items={['Before', 'Transaction', 'Homomorphic Math', 'After']}>
  <Tabs.Tab>
    **Initial State**
    
    ```
    Alice's balance: E(500) = (L_a, R_a)
    Bob's balance:   E(200) = (L_b, R_b)
    Transfer amount: 100 DERO
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    **Create Transfer**
    
    ```
    Create transfer commitment:
      E(100) = (L_t, R_t)
      
    This goes in transaction as encrypted 'C' commitment
    Network sees: Random elliptic curve points
    Network learns: NOTHING about 100
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    **Homomorphic Operations**
    
    ```
    Alice's new balance:
      E(500) - E(100) = E(400)
      (L_a, R_a) - (L_t, R_t) = (L_a - L_t, R_a - R_t)
      
    Bob's new balance:
      E(200) + E(100) = E(300)
      (L_b, R_b) + (L_t, R_t) = (L_b + L_t, R_b + R_t)
      
    No decryption occurred at any point!
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    **Final State**
    
    ```
    Alice's balance: E(400)
    Bob's balance:   E(300)
    
    Network verified:
      ‚úì Balance conservation
      ‚úì No negative amounts
      ‚úì Alice had sufficient balance
      
    Network never learned:
      ‚úó Actual amounts
      ‚úó Balances
      ‚úó Any values
    ```
  </Tabs.Tab>
</Tabs>

---

## Comparison: Traditional vs DERO

### Balance Storage

| Aspect | Traditional Blockchain | DERO Blockchain |
|--------|----------------------|-----------------|
| **Account** | `alice.eth` | `dero1qy...` |
| **Balance shown** | `500 ETH` üëÅÔ∏è Public | `E(???)` üîí Encrypted |
| **Everyone sees** | Exact amount | Random bytes (66 bytes) |
| **Only owner sees** | Same as everyone | Actual balance (with private key) |
| **Privacy** | ‚ùå Zero | ‚úÖ Complete |
| **Balance lookup** | Instant (public) | Instant (encrypted) |

**The Difference:**
- **Bitcoin/Ethereum:** Your balance is like your bank statement posted on a billboard
- **DERO:** Your balance is permanently locked in a safe only you can open

### Blockchain Architecture Comparison

| Feature | Bitcoin/UTXO | Ethereum (Account) | DERO (Account + Encrypted) |
|---------|-------------|-------------------|---------------------------|
| **Model** | Outputs | Accounts | Accounts |
| **Privacy** | Ring sigs | ‚ùå None | ‚úÖ Encrypted |
| **Smart Contracts** | ‚ùå Limited | ‚úÖ Yes, public | ‚úÖ Yes, **private** |
| **Confirmations** | Slower | Fast | Fast |
| **Balance Lookup** | Scan chain | Instant | Instant + private |

**DERO = Ethereum's simplicity + Privacy coin encryption** üéØ

---

## Real-World Applications

### 1. Instant Balance Queries

**Traditional Privacy Coin:**
```
1. Download entire blockchain
2. Scan all transactions
3. Calculate balance from history
4. Wait minutes to hours

Result: Slow, requires full sync
```

**DERO:**
```
1. Query encrypted balance from node (66 bytes)
2. Decrypt with your private key
3. See balance instantly

Result: Instant, no chain scanning needed
```

### 2. Private Token Systems

**How It Works:**

```mermaid
graph TB
    SC["Smart Contract"] --> A["Alice: E(1000 tokens)"]
    SC --> B["Bob: E(500 tokens)"]
    
    TX["Transfer 100 tokens<br/>Alice ‚Üí Bob"] --> H["Homomorphic Operations"]
    A --> H
    B --> H
    
    H --> A2["Alice: E(900 tokens)"]
    H --> B2["Bob: E(600 tokens)"]
    
    SC --> V["Contract verifies<br/>correctness"]
    V --> OK["Valid<br/>Amounts hidden"]
```

**Key Points:**

**From Source Code** (`dvm/dvm_functions.go:80`):

```basic
// Issue tokens to user
Function IssueAsset() Uint64
    10 SEND_ASSET_TO_ADDRESS(SIGNER(), amount, SCID())  
       // Sends without knowing user's current balance - homomorphic!
End Function

// Result in user's wallet:
User's token balance: E(1000)  ‚Üê Encrypted, only user can decrypt
User's DERO balance:  E(500)   ‚Üê Also encrypted
```

**Traditional tokens (ERC-20):** Balances public in contract  
**DERO tokens:** Balances encrypted in user wallets, transferable peer-to-peer

### 3. Private DeFi Operations

**Swap Example:**
```
Swap 100 DERO for 500 tokens:

  Your DERO:  E(balance_dero) - E(100)
  Your tokens: E(balance_tokens) + E(500)
  
Public sees:
  ‚úì Swap contract called
  ‚úó How much swapped
  ‚úó Who swapped
  ‚úó Resulting balances
```

---

## Technical Implementation

### The C and D Commitments

Every DERO transaction contains encrypted commitments:

**C Commitment (Pedersen Commitment):**

```go
C = amount√óG + blinding√óH

Where:
  amount = Transfer amount (hidden)
  G, H = Generator points (public)
  blinding = Random factor (secret)
  
Properties:
  ‚Ä¢ Binding: Cannot change amount after creating C
  ‚Ä¢ Hiding: Cannot determine amount from C
  ‚Ä¢ Homomorphic: C‚ÇÅ + C‚ÇÇ = C(amount‚ÇÅ + amount‚ÇÇ)
```

**D Commitment (Randomness):**

```go
D = r√óG

Purpose:
  ‚Ä¢ Provides randomness for ElGamal encryption
  ‚Ä¢ Prevents amount correlation attacks
  ‚Ä¢ Enables decryption for intended recipient
```

**Together they enable:**
- ‚úÖ Encrypted amounts in transactions
- ‚úÖ Verifiable without revealing amounts
- ‚úÖ Homomorphic balance updates

**Source:** `cryptography/crypto/algebra_elgamal.go` - ElGamal encryption implementation

### Technical Specifications

| Aspect | Details |
|--------|---------|
| **Encryption Scheme** | ElGamal (additive homomorphism) |
| **Curve** | bn256 (Barreto-Naehrig) 256-bit |
| **Security** | Discrete logarithm problem |
| **Commitment Size** | 66 bytes (33 left + 33 right) |
| **Performance** | ~10ms per operation |
| **Trusted Setup** | ‚ùå None required |

---

## Key Takeaways

### What Homomorphic Encryption Provides

| Feature | Benefit | Impact |
|---------|---------|--------|
| **üîí Encrypted Balances** | Always encrypted | Perfect privacy |
| **‚ûï Math on Encrypted** | Operations without decryption | Privacy never broken |
| **‚ö° Instant Queries** | No chain scanning | Fast balance checks |
| **üîê Private Tokens** | Encrypted token balances | Complete privacy |
| **‚úÖ Verifiable** | Network can verify | Security maintained |
| **üö´ No Trusted Setup** | Pure cryptography | Decentralized |

### What It Enables

- ‚úÖ **Private Smart Contracts** - Impossible on other chains
- ‚úÖ **Instant Balance Lookup** - No blockchain scanning
- ‚úÖ **Encrypted Token Systems** - Private token transfers
- ‚úÖ **Private DeFi** - Encrypted swap operations
- ‚úÖ **Account-Based Privacy** - First blockchain to achieve this

<Callout type="info" emoji="üéØ">
**Architectural Breakthrough:** Account-based blockchains were thought incompatible with strong privacy. DERO proved this assumption wrong through homomorphic encryption, enabling private smart contracts with encrypted balances.
</Callout>

---

## Related Pages

**Privacy Suite:**
- [Ring Signatures](/privacy/ring-signatures) - Transaction anonymity
- [Bulletproofs](/privacy/bulletproofs) - Zero-knowledge range proofs
- [Transaction Privacy](/privacy/transaction-privacy) - Complete privacy flow
- [Payload Proofs](/privacy/payload-proofs) - Prove transfers cryptographically

**Technical Implementation:**
- [DERO Tokens](/basics/tokens) - How tokens use homomorphic encryption
- [Private Smart Contracts](/privacy/private-smart-contracts) - Contract encrypted balances

**Build with Privacy:**
- [Token Contract](/smartContracts/token) - Private token example
- [Wallet RPC API](/rpc-api/wallet-rpc-api) - Send private transactions
