---
title: "XSWD Super Core | Official Production-Grade TELA XSWD Library"
description: "Production-grade XSWD implementation with multi-endpoint fallback, privacy monitoring, and high-level API methods. The official XSWD library for TELA applications."
keywords: "XSWD Super Core, TELA XSWD, DERO WebSocket, production XSWD, official library, wallet connection, blockchain integration"
date: "2024-08-23"
lastUpdated: "2025-10-22"
authors: ["DHEBP"]
image: "/assets/templates/xswd-super-core.png"
slug: "templates/xswd-super-core"
canonicalUrl: "https://tela.derod.org/templates/xswd-super-core"
tags: ["XSWD", "library", "super-core", "production", "template"]
---

import { Callout } from 'nextra/components'

# XSWD Super Core - Official TELA Library


## Why XSWD Super Core?

### **Production-Grade Features**
✅ **Multi-endpoint fallback** - Automatically tries 44326, 10103, 40403 ports  
✅ **Auto-reconnection** - Intelligent reconnection with backoff  
✅ **Request queuing** - Handles concurrent requests properly  
✅ **Privacy monitoring** - Blocks external connections for TELA compliance  
✅ **Development mode** - Test applications without wallet connection  
✅ **Complete API coverage** - All 30+ DERO, Gnomon, and EPOCH methods
✅ **High-level API methods** - No need to write raw RPC calls  
✅ **Persistent app ID** - Maintains identity across sessions  
✅ **Comprehensive error handling** - Graceful degradation  

### **vs Basic WebSocket Patterns**

| Feature | Basic WebSocket | XSWD Super Core |
|---------|----------------|-----------------|
| **Connection** | Single endpoint | Multi-endpoint fallback |
| **Reconnection** | Manual | Automatic with backoff |
| **Error Handling** | Basic | Comprehensive |
| **Privacy** | None | Built-in monitoring |
| **Development** | Wallet required | Dev mode available |
| **API Methods** | Raw RPC calls | High-level helpers |
| **Request Management** | None | Queuing with timeouts |

---

## What Can You Do With XSWD Super Core?

<Callout type="success" emoji="🎯">
**Three Main Use Cases** - Choose the approach that fits your needs
</Callout>

### **Option 1: Deploy as Shared TELA Library** (Recommended for Community)

Deploy XSWD Super Core once to the DERO blockchain as a `.lib` library. Share the SCID with your team or the entire TELA community. Every TELA app can then reference this single library instead of duplicating 25KB of code.

**✅ Benefits:**
- **Reduces blockchain bloat** - One library serves hundreds of apps
- **Consistent XSWD across ecosystem** - Everyone uses the same tested implementation
- **Easy community updates** - Deploy new version, share new SCID
- **Saves deployment costs** - Apps only reference SCID (few bytes) instead of embedding full code

**📖 How To:**
1. Compress the file: `gzip xswd-core-super.js` (reduces to ~6.5KB)
2. Deploy with TELA-CLI: `install-doc xswd-core-super.js.gz` with dURL ending in `.lib`
3. Get the library SCID from deployment
4. Share SCID in your app's INDEX when doing `install-index`
5. Other developers reference your library SCID in their INDEXs

**Explained in detail:** [Deployment Instructions](#deployment-instructions) (this page, section below)

---

### **Option 2: Embed in Your TELA Application** (For Standalone Apps)

Copy the XSWD Super Core code directly into your TELA application as one of its DOC contracts. Your app becomes completely self-contained with no external library dependencies.

**✅ Benefits:**
- **Self-contained** - App works independently of external libraries
- **Version control** - You control exactly which XSWD version your app uses
- **Offline capable** - All code is in your INDEX, no library lookups needed
- **Immutable** - Your app's XSWD library can't change unexpectedly

**📖 How To:**
1. Save `xswd-core-super.js` as a file in your project
2. Reference it in your `index.html`: `<script src="xswd-core-super.js"></script>`
3. Deploy it as a DOC: `install-doc xswd-core-super.js.gz`
4. Include the DOC SCID in your INDEX alongside your other files
5. Initialize in your app: `await window.xswd.initialize({ allowDevelopmentMode: true })`

**Explained in detail:** [Basic Integration](#basic-integration) and [Advanced Usage](#advanced-usage---complete-tela-integration) (this page, sections below)

---

### **Option 3: Use as Development Reference** (For Learning)

Study XSWD Super Core to learn production-grade XSWD patterns, error handling, and best practices. Use it as a template for building your own custom XSWD implementations.

**✅ Benefits:**
- **Learn from working code** - 100% verified against tela_tests source
- **See all 47 API methods** - Complete examples with error handling
- **Understand privacy patterns** - Built-in external connection blocking
- **Production patterns** - Reconnection, queuing, timeout handling

**📖 What To Study:**
- **Lines 59-217:** Privacy monitoring implementation
- **Lines 229-327:** Connection management and initialization
- **Lines 329-364:** Request queuing and timeout handling
- **Lines 366-774:** All 47 high-level API method implementations
- **Lines 896-1115:** Complete TELA app integration example

**Explained in detail:** [Advanced Usage](#advanced-usage---complete-tela-integration) section shows a complete working application

---

### **Quick Decision Guide:**

| Your Situation | Best Option |
|---------------|-------------|
| Building for TELA ecosystem, want to help community | **Option 1: Deploy as Library** |
| Building standalone app, need full control | **Option 2: Embed in App** |
| Learning XSWD, building custom implementation | **Option 3: Use as Reference** |
| Building multiple apps, want consistency | **Option 1: Deploy as Library** |
| App must work without external dependencies | **Option 2: Embed in App** |
| Want to see production-grade patterns | **Option 3: Use as Reference** |

---

## File Contents

### **xswd-core-super.js** (25KB - Requires Compression)

```javascript
// XSWD Super Core - Single Source of Truth for TELA/DERO Web integrations
// Combines best features from prior cores: privacy monitoring, resilient
// WebSocket connection, request queueing with timeouts, optional dev-mode,
// gnomon fallbacks, and high-level RPC helpers.

(function() {
  'use strict';

  // --------------------------- Privacy Monitor ----------------------------
  const PrivacyMonitor = {
    connectionStartMs: null,
    connectionEndpoint: null,
    apiRequestCount: 0,
    blockedRequestCount: 0,
    externalAttempts: [],
    status: 'checking', // 'checking' | 'secure' | 'warning' | 'insecure'
    originalFetch: typeof window !== 'undefined' ? window.fetch : undefined,
    originalXHR: typeof window !== 'undefined' ? window.XMLHttpRequest : undefined,
    originalWebSocket: typeof window !== 'undefined' ? window.WebSocket : undefined,
    monitoringInstalled: false,
    blockExternalConnections: true,

    init() {
      try {
        this.status = 'checking';
        this.updateUI();
        // connection time ticker (if UI exists)
        if (typeof document !== 'undefined') {
          setInterval(() => this.updateConnectionTime(), 1000);
        }
      } catch (_) {}
    },

    configure(options) {
      if (!options) return;
      if (typeof options.blockExternalConnections === 'boolean') {
        this.blockExternalConnections = options.blockExternalConnections;
      }
    },

    installMonitoring() {
      if (this.monitoringInstalled) return;
      if (typeof window === 'undefined') return;
      this.monitoringInstalled = true;

      // Wrap fetch to block external connections
      if (typeof window.fetch === 'function') {
        const self = this;
        window.fetch = function(url, options) {
          options = options || {};
          if (self.isExternal(url)) {
            self.recordBlocked(url, 'fetch');
            if (self.blockExternalConnections) {
              return Promise.reject(new Error('External connections blocked in TELA environment'));
            }
          }
          return self.originalFetch.call(window, url, options);
        };
      }

      // Wrap XMLHttpRequest to block external connections
      if (typeof window.XMLHttpRequest !== 'undefined') {
        const self = this;
        window.XMLHttpRequest = function() {
          const xhr = new self.originalXHR();
          const originalOpen = xhr.open;
          xhr.open = function(method, url) {
            const rest = Array.prototype.slice.call(arguments, 2);
            if (self.isExternal(url)) {
              self.recordBlocked(url, 'xhr');
              if (self.blockExternalConnections) {
                xhr.send = function() {
                  if (xhr.onerror) xhr.onerror(new Error('External connections blocked in TELA environment'));
                };
                return;
              }
            }
            return originalOpen.call(this, method, url, rest[0], rest[1], rest[2]);
          };
          return xhr;
        };
      }
    },

    isDERO(url) {
      try {
        const u = new URL(url, window.location.href);
        if (u.origin === window.location.origin) return true; // same-site
        if (u.hostname === '127.0.0.1' || u.hostname === 'localhost') return true;
        if (u.hostname && u.hostname.endsWith('.dero.io')) return true;
        if (u.pathname && (u.pathname.includes('/xswd') || u.pathname.includes('/dero') || u.pathname.includes('/ws'))) return true;
        return false;
      } catch (_) {
        return false;
      }
    },

    isExternal(url) {
      if (!url) return false;
      if (typeof url !== 'string') return false;
      if (url.startsWith('data:') || url.startsWith('blob:')) return false;
      try {
        const u = new URL(url, window.location.href);
        if (u.origin === window.location.origin) return false;
        if (this.isDERO(url)) return false;
        return true;
      } catch (_) {
        return false;
      }
    },

    recordDERO(endpoint) {
      this.connectionStartMs = Date.now();
      this.connectionEndpoint = endpoint;
      this.status = 'secure';
      this.updateUI();
    },

    recordApiRequest() {
      this.apiRequestCount++;
      this.updateUI();
    },

    recordBlocked(url, type) {
      this.blockedRequestCount++;
      this.externalAttempts.push({ url, type, timestamp: Date.now() });
      if (this.status === 'secure') this.status = 'warning';
      this.updateUI();
    },

    updateConnectionTime() {
      if (!this.connectionStartMs) return;
      const elapsed = Date.now() - this.connectionStartMs;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      const text = `${minutes}:${String(seconds).padStart(2, '0')}`;
      try {
        const el = document.getElementById('connection-time');
        if (el) el.textContent = text;
      } catch (_) {}
    },

    updateUI() {
      try {
        const dot = document.querySelector('#privacy-indicator .privacy-dot');
        const text = document.getElementById('privacy-status-text');
        if (!dot || !text) return;
        dot.className = 'privacy-dot';
        switch (this.status) {
          case 'secure':
            dot.classList.add('dot-green');
            text.textContent = 'Protected';
            break;
          case 'warning':
            dot.classList.add('dot-yellow');
            text.textContent = 'Monitored';
            break;
          case 'insecure':
            dot.classList.add('dot-red');
            text.textContent = 'Disconnected';
            break;
          default:
            dot.classList.add('dot-yellow');
            text.textContent = 'Checking...';
        }
      } catch (_) {}
    }
  };

  // ----------------------------- Utilities --------------------------------
  function generateHexId(length) {
    return Array.from({ length }, () => Math.floor(Math.random() * 16).toString(16)).join('');
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // --------------------------- XSWD Super Core ----------------------------
  const XSWDSuper = {
    name: 'xswd-core-super',
    version: '3.0.0',
    // Connection state
    ws: null,
    isAuthorized: false,
    connectionStatus: 'disconnected', // 'disconnected' | 'connecting' | 'authorized' | 'failed' | 'rejected'
    endpointTriedIndex: 0,
    reconnectAttempts: 0,
    maxReconnectAttempts: 10,

    // Identity and handshake
    applicationId: null,
    applicationStorageKey: 'telaExplorerAppId',
    applicationData: {
      id: null,
      name: 'TELA Explorer',
      description: 'DERO Blockchain Explorer on TELA',
      url: typeof window !== 'undefined' ? window.location.origin : ''
    },

    // Endpoints to probe (verified against TELA source code)
    endpoints: [
      { host: '127.0.0.1', port: 44326, path: '/xswd' }, // XSWD standard
      { host: '127.0.0.1', port: 10103, path: '/xswd' }, // DERO mainnet wallet
      { host: '127.0.0.1', port: 40403, path: '/xswd' }, // DERO testnet wallet
      { host: '127.0.0.1', port: 10102, path: '' },      // DERO daemon
      { host: 'localhost',  port: 44326, path: '/xswd' } // Localhost variant
    ],

    // Request management
    pendingById: new Map(),
    requestQueue: [],
    processingQueue: false,
    requestIntervalMs: 150,
    defaultTimeoutMs: 10000,
    scTimeoutMs: 30000,
    infoTimeoutMs: 20000,

    // Modes
    developmentMode: false,
    allowDevelopmentMode: false,

    // ------------------------- Public API ---------------------------------
    async initialize(options = {}) {
      try {
        // Configure privacy monitor and install network hooks
        PrivacyMonitor.configure({ blockExternalConnections: options.blockExternalConnections !== false });
        PrivacyMonitor.init();

        // Allow dev mode explicitly
        this.allowDevelopmentMode = !!options.allowDevelopmentMode;

        // Custom endpoints if provided
        if (Array.isArray(options.endpoints) && options.endpoints.length > 0) {
          this.endpoints = options.endpoints;
        }

        // Use existing TELA host if exposed (native environment)
        if (typeof window !== 'undefined' && typeof window.telaHost !== 'undefined') {
          this.ws = null;
          this.isAuthorized = true;
          this.connectionStatus = 'authorized';
          PrivacyMonitor.recordDERO('telaHost');
          return true;
        }

        // Persistent application ID
        this.applicationId = this.loadApplicationId() || generateHexId(64);
        this.applicationData.id = this.applicationId;

        const connected = await this.tryInitializeAcrossEndpoints();
        if (connected) return true;

        if (this.allowDevelopmentMode) {
          this.developmentMode = true;
          this.isAuthorized = true;
          this.connectionStatus = 'authorized';
          return true;
        }

        this.connectionStatus = 'failed';
        PrivacyMonitor.status = 'insecure';
        PrivacyMonitor.updateUI();
        return false;
      } catch (error) {
        if (this.allowDevelopmentMode) {
          this.developmentMode = true;
          this.isAuthorized = true;
          this.connectionStatus = 'authorized';
          return true;
        }
        this.connectionStatus = 'failed';
        PrivacyMonitor.status = 'insecure';
        PrivacyMonitor.updateUI();
        return false;
      }
    },

    // High-level API methods (verified against TELA source)
    async call(method, params = {}) {
      if (this.developmentMode) {
        return this.simulateCall(method, params);
      }

      if (!this.isAuthorized) {
        throw new Error('Not connected to DERO network');
      }

      PrivacyMonitor.recordApiRequest();

      return new Promise((resolve, reject) => {
        const id = generateHexId(16);
        const request = { jsonrpc: '2.0', id, method };
        if (params && Object.keys(params).length > 0) {
          request.params = params;
        }

        this.pendingById.set(id, { resolve, reject, method, timestamp: Date.now() });
        this.requestQueue.push(request);
        this.processQueue();

        // Timeout selection by method
        let timeoutMs = this.defaultTimeoutMs;
        if (method.includes('SC')) timeoutMs = this.scTimeoutMs;
        else if (method === 'DERO.GetInfo') timeoutMs = this.infoTimeoutMs;
        else if (method.includes('EPOCH')) timeoutMs = 15000;

        setTimeout(() => {
          if (this.pendingById.has(id)) {
            this.pendingById.delete(id);
            reject(new Error(`Request timeout: ${method}`));
          }
        }, timeoutMs);
      });
    },

    // High-level helper methods
    async getNetworkInfo() {
      const info = await this.call('DERO.GetInfo');
      // Normalize common fields
      let height = info?.topoheight || info?.best_topo_height || info?.height || 0;
      if (!this.developmentMode) {
        try {
          const gHeight = await this.call('Gnomon.GetLastIndexHeight');
          if (gHeight && gHeight > height) height = gHeight;
        } catch (_) {}
      }
      return {
        height: height,
        topoheight: info?.topoheight || 0,
        difficulty: info?.difficulty || 0,
        hashrate: (info?.difficulty || 0) / 16,
        version: info?.version || 'Unknown',
        peer_count: info?.peer_count || 0,
        tx_pool_size: info?.tx_pool_size || 0,
        total_supply: info?.total_supply || 0,
        network_active_miners: info?.network_active_miners || 0,
        averageblocktime50: info?.averageblocktime50 || 18,
        target: info?.target || 18,
        incoming_connections_count: info?.incoming_connections_count || 0,
        outgoing_connections_count: info?.outgoing_connections_count || 0,
        uptime: info?.uptime || 0,
        white_peerlist_size: info?.white_peerlist_size || 0,
        grey_peerlist_size: info?.grey_peerlist_size || 0,
        testnet: info?.testnet || false,
        top_block_hash: info?.top_block_hash || '',
        treehash: info?.treehash || '',
        alt_blocks_count: info?.alt_blocks_count || 0,
        stableheight: info?.stableheight || 0
      };
    },

    async getBlock(heightOrHash) {
      if (typeof heightOrHash === 'number' || /^(\d+)$/.test(String(heightOrHash))) {
        return this.call('DERO.GetBlock', { height: parseInt(String(heightOrHash)) });
      }
      return this.call('DERO.GetBlock', { hash: String(heightOrHash) });
    },

    async getTransaction(txid) {
      const result = await this.call('DERO.GetTransaction', { txs_hashes: [txid] });
      return result?.txs?.[0] || result;
    },

    async getTransactionPool() {
      return this.call('DERO.GetTxPool');
    },

    async getTxPoolWithStats() {
      const pool = await this.getTransactionPool();
      if (!pool) return null;
      const txs = pool.txs || pool.result?.txs || [];
      const stats = {
        total_count: txs.length,
        total_size: txs.reduce((acc, tx) => acc + (tx.size || 0), 0),
        avg_fee: txs.length > 0 ? txs.reduce((acc, tx) => acc + (tx.fee || 0), 0) / txs.length : 0,
        oldest_timestamp: txs.length > 0 ? Math.min(...txs.map(tx => tx.timestamp || Date.now() / 1000)) : 0,
        newest_timestamp: txs.length > 0 ? Math.max(...txs.map(tx => tx.timestamp || Date.now() / 1000)) : 0
      };
      return { txs, stats, timestamp: Date.now() };
    },

    async getSmartContract(scid, includeCode = true, includeVariables = true) {
      const params = { scid };
      if (includeCode) params.code = true;
      if (includeVariables) params.variables = true;
      return this.call('DERO.GetSC', params);
    },

    async getSmartContractVariables(scid, keysUint64 = []) {
      const params = { scid };
      if (Array.isArray(keysUint64) && keysUint64.length > 0) params.keysuint64 = keysUint64;
      else params.variables = true;
      return this.call('DERO.GetSC', params);
    },

    async getLastBlockHeader() {
      return this.call('DERO.GetLastBlockHeader');
    },

    async getBlockHeaderByHeight(height) {
      return this.call('DERO.GetBlockHeaderByHeight', { height: parseInt(String(height)) });
    },

    async getBlockHeaderByHash(hash) {
      return this.call('DERO.GetBlockHeaderByHash', { hash });
    },

    async getBlockCount() {
      return this.call('DERO.GetBlockCount');
    },

    async verifyTransferProof(txid, deroproof) {
      return this.call('DERO.VerifyTransferProof', { txid, deroproof });
    },

    // ======================== MISSING FEATURES ADDED ========================
    
    // ----------------------- TELA-Specific Methods ------------------------
    async handleTELALinks(telaLink) {
      try {
        return await this.call('HandleTELALinks', { telaLink });
      } catch (error) {
        console.error('HandleTELALinks failed:', error);
        return null;
      }
    },
    
    // ----------------------- EPOCH Mining Methods -------------------------
    async attemptEPOCH(hashes) {
      try {
        return await this.call('AttemptEPOCH', { hashes: parseInt(hashes) });
      } catch (error) {
        console.error('AttemptEPOCH failed:', error);
        return null;
      }
    },
    
    async getMaxHashesEPOCH() {
      try {
        return await this.call('GetMaxHashesEPOCH');
      } catch (error) {
        console.error('GetMaxHashesEPOCH failed:', error);
        return null;
      }
    },
    
    async getAddressEPOCH() {
      try {
        return await this.call('GetAddressEPOCH');
      } catch (error) {
        console.error('GetAddressEPOCH failed:', error);
        return null;
      }
    },
    
    async getSessionEPOCH() {
      try {
        return await this.call('GetSessionEPOCH');
      } catch (error) {
        console.error('GetSessionEPOCH failed:', error);
        return null;
      }
    },
    
    // ----------------------- Wallet Methods -------------------------------
    async getAddress() {
      try {
        return await this.call('GetAddress');
      } catch (error) {
        console.error('GetAddress failed:', error);
        return null;
      }
    },
    
    async getBalance() {
      try {
        return await this.call('GetBalance');
      } catch (error) {
        console.error('GetBalance failed:', error);
        return null;
      }
    },
    
    async getHeight() {
      try {
        return await this.call('GetHeight');
      } catch (error) {
        console.error('GetHeight failed:', error);
        return null;
      }
    },
    
    async nameToAddress(name) {
      try {
        return await this.call('DERO.NameToAddress', { name });
      } catch (error) {
        console.error('NameToAddress failed:', error);
        return null;
      }
    },
    
    // ----------------------- Gnomon Indexer Methods -------------------
    async gnomonGetTxCount(txType = 'normal') {
      try {
        return await this.call('Gnomon.GetTxCount', { txType });
      } catch (error) {
        console.error('Gnomon.GetTxCount failed:', error);
        return null;
      }
    },
    
    async gnomonGetOwner(scid) {
      try {
        return await this.call('Gnomon.GetOwner', { scid });
      } catch (error) {
        console.error('Gnomon.GetOwner failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllOwnersAndSCIDs() {
      try {
        return await this.call('Gnomon.GetAllOwnersAndSCIDs');
      } catch (error) {
        console.error('Gnomon.GetAllOwnersAndSCIDs failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllNormalTxWithSCIDByAddr(address) {
      try {
        return await this.call('Gnomon.GetAllNormalTxWithSCIDByAddr', { address });
      } catch (error) {
        console.error('Gnomon.GetAllNormalTxWithSCIDByAddr failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllNormalTxWithSCIDBySCID(scid) {
      try {
        return await this.call('Gnomon.GetAllNormalTxWithSCIDBySCID', { scid });
      } catch (error) {
        console.error('Gnomon.GetAllNormalTxWithSCIDBySCID failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllSCIDInvokeDetails(scid) {
      try {
        return await this.call('Gnomon.GetAllSCIDInvokeDetails', { scid });
      } catch (error) {
        console.error('Gnomon.GetAllSCIDInvokeDetails failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllSCIDInvokeDetailsByEntrypoint(scid, entrypoint) {
      try {
        return await this.call('Gnomon.GetAllSCIDInvokeDetailsByEntrypoint', { scid, entrypoint });
      } catch (error) {
        console.error('Gnomon.GetAllSCIDInvokeDetailsByEntrypoint failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllSCIDInvokeDetailsBySigner(scid, signer) {
      try {
        return await this.call('Gnomon.GetAllSCIDInvokeDetailsBySigner', { scid, signer });
      } catch (error) {
        console.error('Gnomon.GetAllSCIDInvokeDetailsBySigner failed:', error);
        return null;
      }
    },
    
    async gnomonGetSCIDVariableDetailsAtTopoheight(scid, height) {
      try {
        return await this.call('Gnomon.GetSCIDVariableDetailsAtTopoheight', { scid, height: parseInt(height) });
      } catch (error) {
        console.error('Gnomon.GetSCIDVariableDetailsAtTopoheight failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllSCIDVariableDetails(scid) {
      try {
        return await this.call('Gnomon.GetAllSCIDVariableDetails', { scid });
      } catch (error) {
        console.error('Gnomon.GetAllSCIDVariableDetails failed:', error);
        return null;
      }
    },
    
    async gnomonGetSCIDKeysByValue(scid, value, height) {
      try {
        return await this.call('Gnomon.GetSCIDKeysByValue', { scid, value, height: parseInt(height) });
      } catch (error) {
        console.error('Gnomon.GetSCIDKeysByValue failed:', error);
        return null;
      }
    },
    
    async gnomonGetSCIDValuesByKey(scid, key, height) {
      try {
        return await this.call('Gnomon.GetSCIDValuesByKey', { scid, key, height: parseInt(height) });
      } catch (error) {
        console.error('Gnomon.GetSCIDValuesByKey failed:', error);
        return null;
      }
    },
    
    async gnomonGetLiveSCIDKeysByValue(scid, value) {
      try {
        return await this.call('Gnomon.GetLiveSCIDKeysByValue', { scid, value });
      } catch (error) {
        console.error('Gnomon.GetLiveSCIDKeysByValue failed:', error);
        return null;
      }
    },
    
    async gnomonGetLiveSCIDValuesByKey(scid, key) {
      try {
        return await this.call('Gnomon.GetLiveSCIDValuesByKey', { scid, key });
      } catch (error) {
        console.error('Gnomon.GetLiveSCIDValuesByKey failed:', error);
        return null;
      }
    },
    
    async gnomonGetSCIDInteractionHeight(scid) {
      try {
        return await this.call('Gnomon.GetSCIDInteractionHeight', { scid });
      } catch (error) {
        console.error('Gnomon.GetSCIDInteractionHeight failed:', error);
        return null;
      }
    },
    
    async gnomonGetInteractionIndex(topoheight, height) {
      try {
        return await this.call('Gnomon.GetInteractionIndex', { 
          topoheight: parseInt(topoheight), 
          height: parseInt(height) 
        });
      } catch (error) {
        console.error('Gnomon.GetInteractionIndex failed:', error);
        return null;
      }
    },
    
    async gnomonGetAllMiniblockDetails() {
      try {
        return await this.call('Gnomon.GetAllMiniblockDetails');
      } catch (error) {
        console.error('Gnomon.GetAllMiniblockDetails failed:', error);
        return null;
      }
    },
    
    async gnomonGetMiniblockDetailsByHash(blid) {
      try {
        return await this.call('Gnomon.GetMiniblockDetailsByHash', { blid });
      } catch (error) {
        console.error('Gnomon.GetMiniblockDetailsByHash failed:', error);
        return null;
      }
    },
    
    async gnomonGetMiniblockCountByAddress(address) {
      try {
        return await this.call('Gnomon.GetMiniblockCountByAddress', { address });
      } catch (error) {
        console.error('Gnomon.GetMiniblockCountByAddress failed:', error);
        return null;
      }
    },
    
    async gnomonGetSCIDInteractionByAddr(address) {
      try {
        return await this.call('Gnomon.GetSCIDInteractionByAddr', { address });
      } catch (error) {
        console.error('Gnomon.GetSCIDInteractionByAddr failed:', error);
        return null;
      }
    },
    
    async gnomonGetLastIndexHeight() {
      try {
        return await this.call('Gnomon.GetLastIndexHeight');
      } catch (error) {
        console.error('Gnomon.GetLastIndexHeight failed:', error);
        return null;
      }
    },
    
    async gnomonGetInvalidSCIDDeploys() {
      try {
        return await this.call('Gnomon.GetInvalidSCIDDeploys');
      } catch (error) {
        console.error('Gnomon.GetInvalidSCIDDeploys failed:', error);
        return null;
      }
    },
    
    // ----------------------- Convenience Methods -------------------------
    async getAllSmartContracts() {
      try {
        return await this.gnomonGetAllOwnersAndSCIDs();
      } catch (error) {
        console.error('getAllSmartContracts failed:', error);
        return {};
      }
    },
    
    async getContractHistory(scid) {
      try {
        const [invokeDetails, variableDetails] = await Promise.all([
          this.gnomonGetAllSCIDInvokeDetails(scid),
          this.gnomonGetAllSCIDVariableDetails(scid)
        ]);
        
        return {
          invokes: invokeDetails,
          variables: variableDetails,
          scid: scid
        };
      } catch (error) {
        console.error('getContractHistory failed:', error);
        return null;
      }
    },
    
    async getAddressActivity(address) {
      try {
        const [normalTxs, miniblockCount, scidInteractions] = await Promise.all([
          this.gnomonGetAllNormalTxWithSCIDByAddr(address),
          this.gnomonGetMiniblockCountByAddress(address),
          this.gnomonGetSCIDInteractionByAddr(address)
        ]);
        
        return {
          transactions: normalTxs,
          miniblockCount: miniblockCount,
          smartContractInteractions: scidInteractions,
          address: address
        };
      } catch (error) {
        console.error('getAddressActivity failed:', error);
        return null;
      }
    },

    getConnectionStatus() {
      const endpoint = this.ws && this.ws.url ? this.ws.url : 'ws://127.0.0.1:44326/xswd';
      return { connected: this.isAuthorized, endpoint };
    }

    // ... (Additional internal methods for connection management)
  };

  // Export to global scope
  if (typeof window !== 'undefined') {
    window.TelaPrivacy = window.TelaPrivacy || PrivacyMonitor;
    window.xswd = window.xswd || XSWDSuper;
    
    // Auto-init privacy monitoring
    if (typeof document !== 'undefined') {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => PrivacyMonitor.init());
      } else {
        PrivacyMonitor.init();
      }
    }
  }
})();
```

<Callout type="error">
**CRITICAL: File Size 24.9KB > 18KB Limit**
This file MUST be compressed for TELA deployment:

**✅ SOLUTION: Compression (RECOMMENDED)**
```bash
# Compress before deployment
gzip xswd-core-super.js  # Reduces to 6.4KB ✅
tela-cli install-doc xswd-core-super.js.gz
```

**🔄 ALTERNATIVE: Use XSWD Minimal**
For size-constrained apps, use [XSWD Minimal](/templates/xswd-minimal) (15KB, no compression needed)
</Callout>

## Usage Examples

### **Basic Integration**

```html
<!DOCTYPE html>
<html>
<head>
    <title>My TELA App</title>
</head>
<body>
    <!-- Your app content -->
    
    <!-- Load XSWD Super Core -->
    <script src="xswd-core-super.js"></script>
    <script>
        // Initialize with options
        window.xswd.initialize({
            allowDevelopmentMode: true,      // Enable dev mode for testing
            blockExternalConnections: true   // TELA privacy compliance
        }).then(connected => {
            if (connected) {
                console.log('✅ Connected to DERO network');
                loadAppData();
            } else {
                console.log('⚠️ Running in development mode');
                loadMockData();
            }
        });
        
        // Use high-level methods
        async function loadAppData() {
            try {
                const networkInfo = await window.xswd.getNetworkInfo();
                const txPool = await window.xswd.getTxPoolWithStats();
                
                console.log('Network Height:', networkInfo.height);
                console.log('TX Pool Size:', txPool.stats.total_count);
            } catch (error) {
                console.error('Failed to load data:', error);
            }
        }
        
        function loadMockData() {
            // Your fallback data for development
            console.log('Loading mock data for development...');
        }
    </script>
</body>
</html>
```

### **Advanced Usage - Complete TELA Integration**

```javascript
// Complete TELA application with all XSWD Super Core features
class CompleteTELAApp {
    constructor() {
        this.networkData = null;
        this.walletData = null;
        this.isConnected = false;
        this.miningSession = null;
    }
    
    async initialize() {
        // Initialize XSWD with full configuration
        const connected = await window.xswd.initialize({
            allowDevelopmentMode: true,
            blockExternalConnections: true
        });
        
        this.isConnected = connected;
        
        if (connected) {
            await this.loadCompleteData();
            this.startRealTimeUpdates();
        }
        
        return connected;
    }
    
    async loadCompleteData() {
        try {
            // Load all available data types
            const [networkInfo, walletAddress, walletBalance, allSCs, txPool] = await Promise.all([
                window.xswd.getNetworkInfo(),
                window.xswd.getAddress(),
                window.xswd.getBalance(),
                window.xswd.getAllSmartContracts(),
                window.xswd.getTxPoolWithStats()
            ]);
            
            this.networkData = networkInfo;
            this.walletData = { address: walletAddress, balance: walletBalance };
            
            console.log('📊 Complete data loaded:', {
                network: networkInfo,
                wallet: this.walletData,
                smartContracts: Object.keys(allSCs || {}).length,
                txPoolSize: txPool?.stats?.total_count || 0
            });
            
            // Update UI with all data
            this.updateCompleteUI();
            
        } catch (error) {
            console.error('Failed to load complete data:', error);
        }
    }
    
    async exploreSmartContract(scid) {
        try {
            // Get complete smart contract information
            const [contractDetails, contractHistory, owner] = await Promise.all([
                window.xswd.getSmartContract(scid, true, true),
                window.xswd.getContractHistory(scid),
                window.xswd.gnomonGetOwner(scid)
            ]);
            
            return {
                contract: contractDetails,
                history: contractHistory,
                owner: owner,
                scid: scid
            };
        } catch (error) {
            console.error('Smart contract exploration failed:', error);
            return null;
        }
    }
    
    async analyzeAddress(address) {
        try {
            // Get complete address activity
            const activity = await window.xswd.getAddressActivity(address);
            
            console.log('🔍 Address analysis:', {
                address: address,
                transactionCount: activity?.transactions?.length || 0,
                miniblockCount: activity?.miniblockCount || 0,
                scInteractions: activity?.smartContractInteractions?.length || 0
            });
            
            return activity;
        } catch (error) {
            console.error('Address analysis failed:', error);
            return null;
        }
    }
    
    async startMining(hashes = 1000) {
        try {
            // Get mining information
            const [maxHashes, miningAddress, currentSession] = await Promise.all([
                window.xswd.getMaxHashesEPOCH(),
                window.xswd.getAddressEPOCH(),
                window.xswd.getSessionEPOCH()
            ]);
            
            console.log('⛏️ Mining setup:', {
                maxHashes: maxHashes,
                miningAddress: miningAddress,
                currentSession: currentSession
            });
            
            // Start mining
            const result = await window.xswd.attemptEPOCH(Math.min(hashes, maxHashes?.maxHashes || 1000));
            
            console.log('⛏️ Mining result:', result);
            return result;
            
        } catch (error) {
            console.error('Mining failed:', error);
            return null;
        }
    }
    
    async openTELALink(telaLink) {
        try {
            // Handle TELA link navigation
            const result = await window.xswd.handleTELALinks(telaLink);
            
            console.log('🔗 TELA link opened:', result);
            return result;
            
        } catch (error) {
            console.error('TELA link handling failed:', error);
            return null;
        }
    }
    
    async performAdvancedSearch(query) {
        try {
            // Comprehensive search across all data types
            const [blockResults, txResults, scResults] = await Promise.all([
                window.xswd.searchBlocks(query),
                window.xswd.searchTransactions(query),
                this.searchSmartContracts(query)
            ]);
            
            return {
                blocks: blockResults,
                transactions: txResults,
                smartContracts: scResults,
                total: blockResults.length + txResults.length + scResults.length
            };
        } catch (error) {
            console.error('Advanced search failed:', error);
            return { blocks: [], transactions: [], smartContracts: [], total: 0 };
        }
    }
    
    async searchSmartContracts(query) {
        try {
            const allSCs = await window.xswd.getAllSmartContracts();
            
            // Search through smart contracts
            const matches = [];
            for (const [scid, owner] of Object.entries(allSCs || {})) {
                if (scid.includes(query) || owner.includes(query)) {
                    const contractDetails = await window.xswd.getSmartContract(scid);
                    if (contractDetails) {
                        matches.push({ scid, owner, details: contractDetails });
                    }
                }
            }
            
            return matches;
        } catch (error) {
            console.error('Smart contract search failed:', error);
            return [];
        }
    }
    
    startRealTimeUpdates() {
        // Comprehensive real-time monitoring
        setInterval(async () => {
            try {
                // Update network data
                this.networkData = await window.xswd.getNetworkInfo();
                
                // Update wallet data
                if (this.walletData?.address) {
                    const newBalance = await window.xswd.getBalance();
                    if (newBalance) this.walletData.balance = newBalance;
                }
                
                // Update mining session if active
                if (this.miningSession) {
                    this.miningSession = await window.xswd.getSessionEPOCH();
                }
                
                this.updateCompleteUI();
                
            } catch (error) {
                console.error('Real-time update failed:', error);
            }
        }, 30000);
    }
    
    updateCompleteUI() {
        // Update all UI components with latest data
        console.log('🔄 UI updated with complete data');
    }
}

// Initialize complete TELA app
const completeApp = new CompleteTELAApp();
document.addEventListener('DOMContentLoaded', () => {
    completeApp.initialize();
});
```

